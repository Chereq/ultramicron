; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32l1xx_aes.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32l1xx_aes.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32L1xx_DFP\1.0.2\Device\Include -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DUSE_STM32L152_EVAL ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_aes.c]
                          THUMB

                          AREA ||i.AES_ClearFlag||, CODE, READONLY, ALIGN=2

                  AES_ClearFlag PROC
;;;489      */
;;;490    void AES_ClearFlag(uint32_t AES_FLAG)
000000  4905              LDR      r1,|L1.24|
;;;491    {
;;;492      /* Check the parameters */
;;;493      assert_param(IS_AES_FLAG(AES_FLAG));
;;;494    
;;;495      /* Check if AES_FLAG is AES_FLAG_CCF */
;;;496      if (AES_FLAG == AES_FLAG_CCF)
000002  2801              CMP      r0,#1
;;;497      {
;;;498        /* Clear CCF flag by setting CCFC bit */
;;;499        AES->CR |= (uint32_t) AES_CR_CCFC;
;;;500      }
;;;501      else /* AES_FLAG is AES_FLAG_RDERR or AES_FLAG_WRERR */
;;;502      {
;;;503        /* Clear RDERR and WRERR flags by setting ERRC bit */
;;;504        AES->CR |= (uint32_t) AES_CR_ERRC;
000004  6808              LDR      r0,[r1,#0]
000006  d003              BEQ      |L1.16|
000008  f4407080          ORR      r0,r0,#0x100
                  |L1.12|
00000c  6008              STR      r0,[r1,#0]            ;499
;;;505      }
;;;506    }
00000e  4770              BX       lr
                  |L1.16|
000010  f0400080          ORR      r0,r0,#0x80           ;499
000014  e7fa              B        |L1.12|
;;;507    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      0x50060000

                          AREA ||i.AES_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  AES_ClearITPendingBit PROC
;;;577      */
;;;578    void AES_ClearITPendingBit(uint32_t AES_IT)
000000  4902              LDR      r1,|L2.12|
;;;579    {
;;;580      /* Check the parameters */
;;;581      assert_param(IS_AES_IT(AES_IT));
;;;582    
;;;583      /* Clear the interrupt pending bit */
;;;584      AES->CR |= (uint32_t) (AES_IT >> (uint32_t) 0x00000002);
000002  680a              LDR      r2,[r1,#0]
000004  ea420090          ORR      r0,r2,r0,LSR #2
000008  6008              STR      r0,[r1,#0]
;;;585    }
00000a  4770              BX       lr
;;;586    
                          ENDP

                  |L2.12|
                          DCD      0x50060000

                          AREA ||i.AES_Cmd||, CODE, READONLY, ALIGN=2

                  AES_Cmd PROC
;;;198      */
;;;199    void AES_Cmd(FunctionalState NewState)
000000  4905              LDR      r1,|L3.24|
;;;200    {
;;;201      /* Check the parameter */
;;;202      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;203    
;;;204      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;205      {
;;;206        /* Enable the AES peripheral */
;;;207        AES->CR |= (uint32_t) AES_CR_EN;   /**< AES Enable */
;;;208      }
;;;209      else
;;;210      {
;;;211        /* Disable the AES peripheral */
;;;212        AES->CR &= (uint32_t)(~AES_CR_EN);  /**< AES Disable */
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L3.14|
000008  f0400001          ORR      r0,r0,#1              ;207
00000c  e001              B        |L3.18|
                  |L3.14|
00000e  f0200001          BIC      r0,r0,#1
                  |L3.18|
000012  6008              STR      r0,[r1,#0]            ;207
;;;213      }
;;;214    }
000014  4770              BX       lr
;;;215    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0x50060000

                          AREA ||i.AES_DMAConfig||, CODE, READONLY, ALIGN=2

                  AES_DMAConfig PROC
;;;383      */
;;;384    void AES_DMAConfig(uint32_t AES_DMATransfer, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;385    {
;;;386      /* Check the parameter */
;;;387      assert_param(IS_AES_DMA_TRANSFER(AES_DMATransfer));
;;;388    
;;;389      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;390      {
;;;391        /* Enable the DMA transfer */
;;;392        AES->CR |= (uint32_t) AES_DMATransfer;
;;;393      }
;;;394      else
;;;395      {
;;;396        /* Disable the DMA transfer */
;;;397        AES->CR &= (uint32_t)(~AES_DMATransfer);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;392
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6011              STR      r1,[r2,#0]            ;392
;;;398      }
;;;399    }
000010  4770              BX       lr
;;;400    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x50060000

                          AREA ||i.AES_DeInit||, CODE, READONLY, ALIGN=1

                  AES_DeInit PROC
;;;114      */
;;;115    void AES_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117      /* Enable AES reset state */
;;;118      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_AES, ENABLE);
000002  2101              MOVS     r1,#1
000004  06cc              LSLS     r4,r1,#27
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_AHBPeriphResetCmd
;;;119      /* Release AES from reset state */
;;;120      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_AES, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_AHBPeriphResetCmd
;;;121    }
;;;122    
                          ENDP


                          AREA ||i.AES_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  AES_GetFlagStatus PROC
;;;457      */
;;;458    FlagStatus AES_GetFlagStatus(uint32_t AES_FLAG)
000000  4a03              LDR      r2,|L6.16|
;;;459    {
000002  4601              MOV      r1,r0
;;;460      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;461    
;;;462      /* Check parameters */
;;;463      assert_param(IS_AES_FLAG(AES_FLAG));
;;;464    
;;;465      if ((AES->SR & AES_FLAG) != (uint32_t)RESET)
000006  6852              LDR      r2,[r2,#4]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L6.14|
;;;466      {
;;;467        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L6.14|
;;;468      }
;;;469      else
;;;470      {
;;;471        bitstatus = RESET;
;;;472      }
;;;473        
;;;474      /* Return the AES_FLAG status */
;;;475      return  bitstatus;
;;;476    }
00000e  4770              BX       lr
;;;477    
                          ENDP

                  |L6.16|
                          DCD      0x50060000

                          AREA ||i.AES_GetITStatus||, CODE, READONLY, ALIGN=2

                  AES_GetITStatus PROC
;;;515      */
;;;516    ITStatus AES_GetITStatus(uint32_t AES_IT)
000000  490d              LDR      r1,|L7.56|
;;;517    {
000002  b510              PUSH     {r4,lr}
000004  4603              MOV      r3,r0
;;;518      ITStatus itstatus = RESET;
;;;519      uint32_t cciebitstatus = RESET, ccfbitstatus = RESET;
;;;520    
;;;521      /* Check parameters */
;;;522      assert_param(IS_AES_GET_IT(AES_IT));
;;;523    
;;;524      cciebitstatus = AES->CR & AES_CR_CCIE;
000006  680a              LDR      r2,[r1,#0]
000008  2000              MOVS     r0,#0                 ;518
;;;525      ccfbitstatus =  AES->SR & AES_SR_CCF;
00000a  684c              LDR      r4,[r1,#4]
00000c  f4027200          AND      r2,r2,#0x200          ;524
000010  f0040401          AND      r4,r4,#1
;;;526    
;;;527      /* Check if AES_IT is AES_IT_CC */
;;;528      if (AES_IT == AES_IT_CC)
000014  f5b37f00          CMP      r3,#0x200
000018  d007              BEQ      |L7.42|
;;;529      {
;;;530        /* Check the status of the specified AES interrupt */
;;;531        if (((cciebitstatus) != (uint32_t)RESET) && ((ccfbitstatus) != (uint32_t)RESET))
;;;532        {
;;;533          /* Interrupt occurred */
;;;534          itstatus = SET;
;;;535        }
;;;536        else
;;;537        {
;;;538          /* Interrupt didn't occur */
;;;539          itstatus = RESET;
;;;540        }
;;;541      }
;;;542      else /* AES_IT is AES_IT_ERR */
;;;543      {
;;;544        /* Check the status of the specified AES interrupt */
;;;545        if ((AES->CR & AES_CR_ERRIE) != RESET)
00001a  680a              LDR      r2,[r1,#0]
00001c  0552              LSLS     r2,r2,#21
00001e  d503              BPL      |L7.40|
;;;546        {
;;;547          /* Check if WRERR or RDERR flags are set */
;;;548          if ((AES->SR & (uint32_t)(AES_SR_WRERR | AES_SR_RDERR)) != (uint16_t)RESET)
000020  6849              LDR      r1,[r1,#4]
000022  f0110f06          TST      r1,#6
000026  d104              BNE      |L7.50|
                  |L7.40|
;;;549          {
;;;550            /* Interrupt occurred */
;;;551            itstatus = SET;
;;;552          }
;;;553          else
;;;554          {
;;;555            /* Interrupt didn't occur */
;;;556            itstatus = RESET;
;;;557          }
;;;558        }
;;;559        else
;;;560        {
;;;561          /* Interrupt didn't occur */
;;;562          itstatus = (ITStatus) RESET;
;;;563        }
;;;564      }
;;;565    
;;;566      /* Return the AES_IT status */
;;;567      return itstatus;
;;;568    }
000028  bd10              POP      {r4,pc}
                  |L7.42|
00002a  2a00              CMP      r2,#0                 ;531
00002c  d0fc              BEQ      |L7.40|
00002e  2c00              CMP      r4,#0                 ;531
000030  d0fa              BEQ      |L7.40|
                  |L7.50|
000032  2001              MOVS     r0,#1                 ;534
000034  bd10              POP      {r4,pc}
;;;569    
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      0x50060000

                          AREA ||i.AES_ITConfig||, CODE, READONLY, ALIGN=2

                  AES_ITConfig PROC
;;;429      */
;;;430    void AES_ITConfig(uint32_t AES_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;431    {
;;;432      /* Check the parameters */
;;;433      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;434      assert_param(IS_AES_IT(AES_IT));
;;;435    
;;;436      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;437      {
;;;438        AES->CR |= (uint32_t) AES_IT;    /**< AES_IT Enable */
;;;439      }
;;;440      else
;;;441      {
;;;442        AES->CR &= (uint32_t)(~AES_IT);  /**< AES_IT Disable */
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;438
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6011              STR      r1,[r2,#0]            ;438
;;;443      }
;;;444    }
000010  4770              BX       lr
;;;445    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x50060000

                          AREA ||i.AES_IVInit||, CODE, READONLY, ALIGN=2

                  AES_IVInit PROC
;;;183      */
;;;184    void AES_IVInit(AES_IVInitTypeDef* AES_IVInitStruct)
000000  4904              LDR      r1,|L9.20|
;;;185    {
;;;186      AES->IVR0 = AES_IVInitStruct->AES_IV0;
000002  6802              LDR      r2,[r0,#0]
000004  620a              STR      r2,[r1,#0x20]
;;;187      AES->IVR1 = AES_IVInitStruct->AES_IV1;
000006  6842              LDR      r2,[r0,#4]
000008  624a              STR      r2,[r1,#0x24]
;;;188      AES->IVR2 = AES_IVInitStruct->AES_IV2;
00000a  6882              LDR      r2,[r0,#8]
00000c  628a              STR      r2,[r1,#0x28]
;;;189      AES->IVR3 = AES_IVInitStruct->AES_IV3;
00000e  68c0              LDR      r0,[r0,#0xc]
000010  62c8              STR      r0,[r1,#0x2c]
;;;190    }
000012  4770              BX       lr
;;;191    
                          ENDP

                  |L9.20|
                          DCD      0x50060000

                          AREA ||i.AES_IVStructInit||, CODE, READONLY, ALIGN=1

                  AES_IVStructInit PROC
;;;264      */
;;;265    void AES_IVStructInit(AES_IVInitTypeDef* AES_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;266    {
;;;267      AES_IVInitStruct->AES_IV0 = 0x00000000;
;;;268      AES_IVInitStruct->AES_IV1 = 0x00000000;
000002  6001              STR      r1,[r0,#0]
;;;269      AES_IVInitStruct->AES_IV2 = 0x00000000;
000004  6041              STR      r1,[r0,#4]
;;;270      AES_IVInitStruct->AES_IV3 = 0x00000000;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;271    }
00000a  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.AES_Init||, CODE, READONLY, ALIGN=2

                  AES_Init PROC
;;;134      */
;;;135    void AES_Init(AES_InitTypeDef* AES_InitStruct)
000000  4a06              LDR      r2,|L11.28|
;;;136    {
000002  b510              PUSH     {r4,lr}
;;;137      uint32_t tmpreg = 0;
;;;138      
;;;139      /* Check the parameters */
;;;140      assert_param(IS_AES_MODE(AES_InitStruct->AES_Operation));
;;;141      assert_param(IS_AES_CHAINING(AES_InitStruct->AES_Chaining));
;;;142      assert_param(IS_AES_DATATYPE(AES_InitStruct->AES_DataType));
;;;143    
;;;144      /* Get AES CR register value */
;;;145      tmpreg = AES->CR;
000004  6811              LDR      r1,[r2,#0]
;;;146      
;;;147      /* Clear DATATYPE[1:0], MODE[1:0] and CHMOD[1:0] bits */
;;;148      tmpreg &= (uint32_t)CR_CLEAR_MASK;
000006  f021037e          BIC      r3,r1,#0x7e
00000a  e9d01400          LDRD     r1,r4,[r0,#0]
;;;149      
;;;150      tmpreg |= (AES_InitStruct->AES_Operation | AES_InitStruct->AES_Chaining | AES_InitStruct->AES_DataType);
00000e  6880              LDR      r0,[r0,#8]
000010  4321              ORRS     r1,r1,r4
000012  4318              ORRS     r0,r0,r3
000014  4301              ORRS     r1,r1,r0
;;;151    
;;;152      AES->CR = (uint32_t) tmpreg;
000016  6011              STR      r1,[r2,#0]
;;;153    }
000018  bd10              POP      {r4,pc}
;;;154    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x50060000

                          AREA ||i.AES_KeyInit||, CODE, READONLY, ALIGN=2

                  AES_KeyInit PROC
;;;164      */
;;;165    void AES_KeyInit(AES_KeyInitTypeDef* AES_KeyInitStruct)
000000  4904              LDR      r1,|L12.20|
;;;166    {
;;;167      AES->KEYR0 = AES_KeyInitStruct->AES_Key0;
000002  6802              LDR      r2,[r0,#0]
000004  610a              STR      r2,[r1,#0x10]
;;;168      AES->KEYR1 = AES_KeyInitStruct->AES_Key1;
000006  6842              LDR      r2,[r0,#4]
000008  614a              STR      r2,[r1,#0x14]
;;;169      AES->KEYR2 = AES_KeyInitStruct->AES_Key2;
00000a  6882              LDR      r2,[r0,#8]
00000c  618a              STR      r2,[r1,#0x18]
;;;170      AES->KEYR3 = AES_KeyInitStruct->AES_Key3;
00000e  68c0              LDR      r0,[r0,#0xc]
000010  61c8              STR      r0,[r1,#0x1c]
;;;171    }
000012  4770              BX       lr
;;;172    
                          ENDP

                  |L12.20|
                          DCD      0x50060000

                          AREA ||i.AES_KeyStructInit||, CODE, READONLY, ALIGN=1

                  AES_KeyStructInit PROC
;;;250      */
;;;251    void AES_KeyStructInit(AES_KeyInitTypeDef* AES_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;252    {
;;;253      AES_KeyInitStruct->AES_Key0 = 0x00000000;
;;;254      AES_KeyInitStruct->AES_Key1 = 0x00000000;
000002  6001              STR      r1,[r0,#0]
;;;255      AES_KeyInitStruct->AES_Key2 = 0x00000000;
000004  6041              STR      r1,[r0,#4]
;;;256      AES_KeyInitStruct->AES_Key3 = 0x00000000;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;257    }
00000a  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.AES_ReadIV||, CODE, READONLY, ALIGN=2

                  AES_ReadIV PROC
;;;347      */
;;;348    void AES_ReadIV(AES_IVInitTypeDef* AES_IVInitStruct)
000000  4904              LDR      r1,|L14.20|
;;;349    {
;;;350      AES_IVInitStruct->AES_IV0 = AES->IVR0;
000002  6a0a              LDR      r2,[r1,#0x20]
;;;351      AES_IVInitStruct->AES_IV1 = AES->IVR1;
000004  6002              STR      r2,[r0,#0]
000006  6a4a              LDR      r2,[r1,#0x24]
;;;352      AES_IVInitStruct->AES_IV2 = AES->IVR2;
000008  6042              STR      r2,[r0,#4]
00000a  6a8a              LDR      r2,[r1,#0x28]
;;;353      AES_IVInitStruct->AES_IV3 = AES->IVR3;
00000c  6082              STR      r2,[r0,#8]
00000e  6ac9              LDR      r1,[r1,#0x2c]
000010  60c1              STR      r1,[r0,#0xc]
;;;354    }
000012  4770              BX       lr
;;;355    
                          ENDP

                  |L14.20|
                          DCD      0x50060000

                          AREA ||i.AES_ReadKey||, CODE, READONLY, ALIGN=2

                  AES_ReadKey PROC
;;;326      */
;;;327    void AES_ReadKey(AES_KeyInitTypeDef* AES_KeyInitStruct)
000000  4904              LDR      r1,|L15.20|
;;;328    {
;;;329      AES_KeyInitStruct->AES_Key0 = AES->KEYR0;
000002  690a              LDR      r2,[r1,#0x10]
;;;330      AES_KeyInitStruct->AES_Key1 = AES->KEYR1;
000004  6002              STR      r2,[r0,#0]
000006  694a              LDR      r2,[r1,#0x14]
;;;331      AES_KeyInitStruct->AES_Key2 = AES->KEYR2;
000008  6042              STR      r2,[r0,#4]
00000a  698a              LDR      r2,[r1,#0x18]
;;;332      AES_KeyInitStruct->AES_Key3 = AES->KEYR3;
00000c  6082              STR      r2,[r0,#8]
00000e  69c9              LDR      r1,[r1,#0x1c]
000010  60c1              STR      r1,[r0,#0xc]
;;;333    }
000012  4770              BX       lr
;;;334    
                          ENDP

                  |L15.20|
                          DCD      0x50060000

                          AREA ||i.AES_ReadSubData||, CODE, READONLY, ALIGN=2

                  AES_ReadSubData PROC
;;;310      */
;;;311    uint32_t AES_ReadSubData(void)
000000  4801              LDR      r0,|L16.8|
;;;312    {
;;;313      /* Read Data */
;;;314      return AES->DOUTR;
000002  68c0              LDR      r0,[r0,#0xc]
;;;315    }
000004  4770              BX       lr
;;;316    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x50060000

                          AREA ||i.AES_StructInit||, CODE, READONLY, ALIGN=1

                  AES_StructInit PROC
;;;237      */
;;;238    void AES_StructInit(AES_InitTypeDef* AES_InitStruct)
000000  2100              MOVS     r1,#0
;;;239    {
;;;240      AES_InitStruct->AES_Operation = AES_Operation_Encryp;
;;;241      AES_InitStruct->AES_Chaining = AES_Chaining_ECB;
000002  6001              STR      r1,[r0,#0]
;;;242      AES_InitStruct->AES_DataType = AES_DataType_32b;
000004  6041              STR      r1,[r0,#4]
000006  6081              STR      r1,[r0,#8]
;;;243    }
000008  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.AES_WriteSubData||, CODE, READONLY, ALIGN=2

                  AES_WriteSubData PROC
;;;297      */
;;;298    void AES_WriteSubData(uint32_t Data)
000000  4901              LDR      r1,|L18.8|
;;;299    {
;;;300      /* Write Data */
;;;301      AES->DINR = Data;
000002  6088              STR      r0,[r1,#8]
;;;302    }
000004  4770              BX       lr
;;;303    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x50060000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_aes.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_aes_c_8ada0bca____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_aes_c_8ada0bca____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_aes_c_8ada0bca____REVSH|
#line 144
|__asm___15_stm32l1xx_aes_c_8ada0bca____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
