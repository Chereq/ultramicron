; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32303c_eval\stm32l1xx_lcd.o --asm_dir=.\STM32303C_EVAL\ --list_dir=.\STM32303C_EVAL\ --depend=.\stm32303c_eval\stm32l1xx_lcd.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\\STM32F30x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F30x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32303C_EVAL -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\PACK\Keil\STM32L1xx_DFP\1.0.2\Device\Include -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DUSE_STM32L152_EVAL ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_lcd.c]
                          THUMB

                          AREA ||i.LCD_BlinkConfig||, CODE, READONLY, ALIGN=2

                  LCD_BlinkConfig PROC
;;;347      */
;;;348    void LCD_BlinkConfig(uint32_t LCD_BlinkMode, uint32_t LCD_BlinkFrequency)
000000  4a04              LDR      r2,|L1.20|
;;;349    {
;;;350      /* Check the parameters */
;;;351      assert_param(IS_LCD_BLINK_MODE(LCD_BlinkMode));
;;;352      assert_param(IS_LCD_BLINK_FREQUENCY(LCD_BlinkFrequency));
;;;353      
;;;354      LCD->FCR &= (uint32_t)BLINK_MASK;
000002  6813              LDR      r3,[r2,#0]
000004  f4233378          BIC      r3,r3,#0x3e000
000008  6013              STR      r3,[r2,#0]
;;;355      LCD->FCR |= (uint32_t)(LCD_BlinkMode | LCD_BlinkFrequency);
00000a  6813              LDR      r3,[r2,#0]
00000c  4308              ORRS     r0,r0,r1
00000e  4303              ORRS     r3,r3,r0
000010  6013              STR      r3,[r2,#0]
;;;356    }
000012  4770              BX       lr
;;;357    
                          ENDP

                  |L1.20|
                          DCD      0x40002404

                          AREA ||i.LCD_ClearFlag||, CODE, READONLY, ALIGN=2

                  LCD_ClearFlag PROC
;;;559      */
;;;560    void LCD_ClearFlag(uint32_t LCD_FLAG)
000000  4901              LDR      r1,|L2.8|
;;;561    {
;;;562      /* Check the parameters */
;;;563      assert_param(IS_LCD_CLEAR_FLAG(LCD_FLAG));
;;;564        
;;;565      /* Clear the corresponding LCD flag */
;;;566      LCD->CLR = (uint32_t)LCD_FLAG;
000002  6008              STR      r0,[r1,#0]
;;;567    }
000004  4770              BX       lr
;;;568    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x4000240c

                          AREA ||i.LCD_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  LCD_ClearITPendingBit PROC
;;;614      */
;;;615    void LCD_ClearITPendingBit(uint32_t LCD_IT)
000000  4901              LDR      r1,|L3.8|
;;;616    {
;;;617      /* Check the parameters */
;;;618      assert_param(IS_LCD_IT(LCD_IT));
;;;619      
;;;620      /* Clear the corresponding LCD pending bit */
;;;621      LCD->CLR = (uint32_t)LCD_IT;
000002  6008              STR      r0,[r1,#0]
;;;622    }
000004  4770              BX       lr
;;;623    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x4000240c

                          AREA ||i.LCD_Cmd||, CODE, READONLY, ALIGN=2

                  LCD_Cmd PROC
;;;220      */
;;;221    void LCD_Cmd(FunctionalState NewState)
000000  4901              LDR      r1,|L4.8|
;;;222    {
;;;223      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;224    
;;;225      /* Check the parameters */
;;;226      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;227    
;;;228      *(__IO uint32_t *) CR_LCDEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;229    }
000004  4770              BX       lr
;;;230    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x42048000

                          AREA ||i.LCD_ContrastConfig||, CODE, READONLY, ALIGN=2

                  LCD_ContrastConfig PROC
;;;371      */
;;;372    void LCD_ContrastConfig(uint32_t LCD_Contrast)
000000  4904              LDR      r1,|L5.20|
;;;373    {
;;;374      /* Check the parameters */
;;;375      assert_param(IS_LCD_CONTRAST(LCD_Contrast));
;;;376    
;;;377      LCD->FCR &= (uint32_t)CONTRAST_MASK;
000002  680a              LDR      r2,[r1,#0]
000004  f42252e0          BIC      r2,r2,#0x1c00
000008  600a              STR      r2,[r1,#0]
;;;378      LCD->FCR |= (uint32_t)(LCD_Contrast);
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;379    }
000010  4770              BX       lr
;;;380    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40002404

                          AREA ||i.LCD_DeInit||, CODE, READONLY, ALIGN=1

                  LCD_DeInit PROC
;;;158      */
;;;159    void LCD_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
;;;161      /* Enable LCD reset state */
;;;162      RCC_APB1PeriphResetCmd(RCC_APB1Periph_LCD, ENABLE);
000002  2101              MOVS     r1,#1
000004  024c              LSLS     r4,r1,#9
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;163      /* Release LCD from reset state */
;;;164      RCC_APB1PeriphResetCmd(RCC_APB1Periph_LCD, DISABLE);
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;165    }
;;;166    
                          ENDP


                          AREA ||i.LCD_DeadTimeConfig||, CODE, READONLY, ALIGN=2

                  LCD_DeadTimeConfig PROC
;;;316      */
;;;317    void LCD_DeadTimeConfig(uint32_t LCD_DeadTime)
000000  4904              LDR      r1,|L7.20|
;;;318    {
;;;319      /* Check the parameters */
;;;320      assert_param(IS_LCD_DEAD_TIME(LCD_DeadTime));
;;;321    
;;;322      LCD->FCR &= (uint32_t)DEAD_MASK;
000002  680a              LDR      r2,[r1,#0]
000004  f4227260          BIC      r2,r2,#0x380
000008  600a              STR      r2,[r1,#0]
;;;323      LCD->FCR |= (uint32_t)(LCD_DeadTime);
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;324    }
000010  4770              BX       lr
;;;325    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40002404

                          AREA ||i.LCD_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  LCD_GetFlagStatus PROC
;;;533      */
;;;534    FlagStatus LCD_GetFlagStatus(uint32_t LCD_FLAG)
000000  4a03              LDR      r2,|L8.16|
;;;535    {
000002  4601              MOV      r1,r0
;;;536      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;537      
;;;538      /* Check the parameters */
;;;539      assert_param(IS_LCD_GET_FLAG(LCD_FLAG));
;;;540      
;;;541      if ((LCD->SR & LCD_FLAG) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L8.14|
;;;542      {
;;;543        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L8.14|
;;;544      }
;;;545      else
;;;546      {
;;;547        bitstatus = RESET;
;;;548      }
;;;549      return bitstatus;
;;;550    }
00000e  4770              BX       lr
;;;551    
                          ENDP

                  |L8.16|
                          DCD      0x40002408

                          AREA ||i.LCD_GetITStatus||, CODE, READONLY, ALIGN=2

                  LCD_GetITStatus PROC
;;;579      */
;;;580    ITStatus LCD_GetITStatus(uint32_t LCD_IT)
000000  4a07              LDR      r2,|L9.32|
;;;581    {
;;;582      ITStatus bitstatus = RESET;
000002  2100              MOVS     r1,#0
;;;583      
;;;584      /* Check the parameters */
;;;585      assert_param(IS_LCD_GET_IT(LCD_IT));
;;;586        
;;;587      if ((LCD->SR & LCD_IT) != (uint16_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  4202              TST      r2,r0
000008  d000              BEQ      |L9.12|
;;;588      {
;;;589        bitstatus = SET;
00000a  2101              MOVS     r1,#1
                  |L9.12|
;;;590      }
;;;591      else
;;;592      {
;;;593        bitstatus = RESET;
;;;594      }
;;;595      
;;;596      if (((LCD->FCR & LCD_IT) != (uint16_t)RESET) && (bitstatus != (uint32_t)RESET))
00000c  4a04              LDR      r2,|L9.32|
00000e  1f12              SUBS     r2,r2,#4
000010  6812              LDR      r2,[r2,#0]
000012  4202              TST      r2,r0
000014  d002              BEQ      |L9.28|
000016  b109              CBZ      r1,|L9.28|
;;;597      {
;;;598        bitstatus = SET;
000018  2001              MOVS     r0,#1
;;;599      }
;;;600      else
;;;601      {
;;;602        bitstatus = RESET;
;;;603      }
;;;604      return bitstatus;
;;;605    }
00001a  4770              BX       lr
                  |L9.28|
00001c  2000              MOVS     r0,#0                 ;602
00001e  4770              BX       lr
;;;606    
                          ENDP

                  |L9.32|
                          DCD      0x40002408

                          AREA ||i.LCD_HighDriveCmd||, CODE, READONLY, ALIGN=2

                  LCD_HighDriveCmd PROC
;;;255      */
;;;256    void LCD_HighDriveCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L10.8|
;;;257    {
;;;258      /* Check the parameters */
;;;259      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;260    
;;;261      *(__IO uint32_t *) FCR_HD_BB = (uint32_t)NewState;
000002  f8c10080          STR      r0,[r1,#0x80]
;;;262    }
000006  4770              BX       lr
;;;263    
                          ENDP

                  |L10.8|
                          DCD      0x42048000

                          AREA ||i.LCD_ITConfig||, CODE, READONLY, ALIGN=2

                  LCD_ITConfig PROC
;;;497      */
;;;498    void LCD_ITConfig(uint32_t LCD_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;499    {
;;;500      /* Check the parameters */
;;;501      assert_param(IS_LCD_IT(LCD_IT));
;;;502      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;503      
;;;504      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;505      {
;;;506        LCD->FCR |= LCD_IT;
;;;507      }
;;;508      else
;;;509      {
;;;510        LCD->FCR &= (uint32_t)~LCD_IT;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L11.12|
000008  4301              ORRS     r1,r1,r0              ;506
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  4381              BICS     r1,r1,r0
                  |L11.14|
00000e  6011              STR      r1,[r2,#0]            ;506
;;;511      }
;;;512    }
000010  4770              BX       lr
;;;513    
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40002404

                          AREA ||i.LCD_Init||, CODE, READONLY, ALIGN=2

                  LCD_Init PROC
;;;174      */
;;;175    void LCD_Init(LCD_InitTypeDef* LCD_InitStruct)
000000  4602              MOV      r2,r0
;;;176    {
;;;177      /* Check function parameters */
;;;178      assert_param(IS_LCD_PRESCALER(LCD_InitStruct->LCD_Prescaler));
;;;179      assert_param(IS_LCD_DIVIDER(LCD_InitStruct->LCD_Divider));
;;;180      assert_param(IS_LCD_DUTY(LCD_InitStruct->LCD_Duty));
;;;181      assert_param(IS_LCD_BIAS(LCD_InitStruct->LCD_Bias));
;;;182      assert_param(IS_LCD_VOLTAGE_SOURCE(LCD_InitStruct->LCD_VoltageSource));
;;;183    
;;;184      LCD->FCR &= (uint32_t)FCR_MASK;
000002  480e              LDR      r0,|L12.60|
000004  b500              PUSH     {lr}                  ;176
000006  6801              LDR      r1,[r0,#0]
000008  f021717f          BIC      r1,r1,#0x3fc0000
00000c  6001              STR      r1,[r0,#0]
00000e  e9d21300          LDRD     r1,r3,[r2,#0]
;;;185      LCD->FCR |= (uint32_t)(LCD_InitStruct->LCD_Prescaler | LCD_InitStruct->LCD_Divider);
000012  4319              ORRS     r1,r1,r3
000014  6803              LDR      r3,[r0,#0]
000016  4319              ORRS     r1,r1,r3
000018  6001              STR      r1,[r0,#0]
;;;186    
;;;187      LCD_WaitForSynchro();
00001a  f7fffffe          BL       LCD_WaitForSynchro
;;;188    
;;;189      LCD->CR &= (uint32_t)CR_MASK;
00001e  4807              LDR      r0,|L12.60|
000020  1f00              SUBS     r0,r0,#4
000022  6801              LDR      r1,[r0,#0]
000024  f021017e          BIC      r1,r1,#0x7e
000028  6001              STR      r1,[r0,#0]
;;;190      LCD->CR |= (uint32_t)(LCD_InitStruct->LCD_Duty | LCD_InitStruct->LCD_Bias | \
00002a  6801              LDR      r1,[r0,#0]
00002c  6893              LDR      r3,[r2,#8]
00002e  4319              ORRS     r1,r1,r3
000030  e9d23203          LDRD     r3,r2,[r2,#0xc]
000034  4313              ORRS     r3,r3,r2
000036  4319              ORRS     r1,r1,r3
000038  6001              STR      r1,[r0,#0]
;;;191                            LCD_InitStruct->LCD_VoltageSource);
;;;192    
;;;193    }
00003a  bd00              POP      {pc}
;;;194    
                          ENDP

                  |L12.60|
                          DCD      0x40002404

                          AREA ||i.LCD_MuxSegmentCmd||, CODE, READONLY, ALIGN=2

                  LCD_MuxSegmentCmd PROC
;;;270      */
;;;271    void LCD_MuxSegmentCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L13.8|
;;;272    {
;;;273      /* Check the parameters */
;;;274      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;275    
;;;276      *(__IO uint32_t *) CR_MUX_SEG_BB = (uint32_t)NewState;
000002  61c8              STR      r0,[r1,#0x1c]
;;;277    }
000004  4770              BX       lr
;;;278    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x42048000

                          AREA ||i.LCD_PulseOnDurationConfig||, CODE, READONLY, ALIGN=2

                  LCD_PulseOnDurationConfig PROC
;;;293      */
;;;294    void LCD_PulseOnDurationConfig(uint32_t LCD_PulseOnDuration)
000000  4904              LDR      r1,|L14.20|
;;;295    {
;;;296      /* Check the parameters */
;;;297      assert_param(IS_LCD_PULSE_ON_DURATION(LCD_PulseOnDuration));
;;;298    
;;;299      LCD->FCR &= (uint32_t)PON_MASK;
000002  680a              LDR      r2,[r1,#0]
000004  f0220270          BIC      r2,r2,#0x70
000008  600a              STR      r2,[r1,#0]
;;;300      LCD->FCR |= (uint32_t)(LCD_PulseOnDuration);
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;301    }
000010  4770              BX       lr
;;;302    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40002404

                          AREA ||i.LCD_StructInit||, CODE, READONLY, ALIGN=1

                  LCD_StructInit PROC
;;;200      */
;;;201    void LCD_StructInit(LCD_InitTypeDef* LCD_InitStruct)
000000  2100              MOVS     r1,#0
;;;202    {
;;;203    /*--------------- Reset LCD init structure parameters values -----------------*/
;;;204      LCD_InitStruct->LCD_Prescaler = LCD_Prescaler_1; /*!< Initialize the LCD_Prescaler member */
;;;205      
;;;206      LCD_InitStruct->LCD_Divider = LCD_Divider_16; /*!< Initialize the LCD_Divider member */
000002  6001              STR      r1,[r0,#0]
;;;207      
;;;208      LCD_InitStruct->LCD_Duty = LCD_Duty_Static; /*!< Initialize the LCD_Duty member */
000004  6041              STR      r1,[r0,#4]
;;;209      
;;;210      LCD_InitStruct->LCD_Bias = LCD_Bias_1_4; /*!< Initialize the LCD_Bias member */
000006  6081              STR      r1,[r0,#8]
;;;211      
;;;212      LCD_InitStruct->LCD_VoltageSource = LCD_VoltageSource_Internal; /*!< Initialize the LCD_VoltageSource member */
000008  60c1              STR      r1,[r0,#0xc]
00000a  6101              STR      r1,[r0,#0x10]
;;;213    }
00000c  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.LCD_UpdateDisplayRequest||, CODE, READONLY, ALIGN=2

                  LCD_UpdateDisplayRequest PROC
;;;466      */
;;;467    void LCD_UpdateDisplayRequest(void)
000000  4902              LDR      r1,|L16.12|
;;;468    {
;;;469      *(__IO uint32_t *) SR_UDR_BB = (uint32_t)0x01;
000002  2001              MOVS     r0,#1
000004  f8c10108          STR      r0,[r1,#0x108]
;;;470    }
000008  4770              BX       lr
;;;471    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x42048000

                          AREA ||i.LCD_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  LCD_WaitForSynchro PROC
;;;236      */
;;;237    void LCD_WaitForSynchro(void)
000000  4802              LDR      r0,|L17.12|
                  |L17.2|
;;;238    {
;;;239      /* Loop until FCRSF flag is set */
;;;240      while ((LCD->SR & LCD_FLAG_FCRSF) == (uint32_t)RESET)
000002  6801              LDR      r1,[r0,#0]
000004  0689              LSLS     r1,r1,#26
000006  d5fc              BPL      |L17.2|
;;;241      {
;;;242      }
;;;243    }
000008  4770              BX       lr
;;;244    
                          ENDP

00000a  0000              DCW      0x0000
                  |L17.12|
                          DCD      0x40002408

                          AREA ||i.LCD_Write||, CODE, READONLY, ALIGN=2

                  LCD_Write PROC
;;;443      */
;;;444    void LCD_Write(uint32_t LCD_RAMRegister, uint32_t LCD_Data)
000000  4a02              LDR      r2,|L18.12|
;;;445    {
;;;446      /* Check the parameters */
;;;447      assert_param(IS_LCD_RAM_REGISTER(LCD_RAMRegister));
;;;448    
;;;449      /* Copy data bytes to RAM register */
;;;450      LCD->RAM[LCD_RAMRegister] = (uint32_t)LCD_Data;
000002  eb020080          ADD      r0,r2,r0,LSL #2
000006  f8c01414          STR      r1,[r0,#0x414]
;;;451    }
00000a  4770              BX       lr
;;;452    
                          ENDP

                  |L18.12|
                          DCD      0x40002000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_lcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_lcd_c_7a40c1c2____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32l1xx_lcd_c_7a40c1c2____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32l1xx_lcd_c_7a40c1c2____REVSH|
#line 144
|__asm___15_stm32l1xx_lcd_c_7a40c1c2____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
