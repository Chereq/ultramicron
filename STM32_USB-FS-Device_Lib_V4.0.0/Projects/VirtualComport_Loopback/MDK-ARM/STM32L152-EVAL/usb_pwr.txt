; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\usb_pwr.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\src\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;93     *******************************************************************************/
;;;94     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;95     {
;;;96       /* disable all interrupts and force USB reset */
;;;97       _SetCNTR(CNTR_FRES);
000002  4c06              LDR      r4,|L1.28|
000004  2001              MOVS     r0,#1
000006  6020              STR      r0,[r4,#0]
;;;98       /* clear interrupt status register */
;;;99       _SetISTR(0);
000008  1d21              ADDS     r1,r4,#4
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]
;;;100      /* Disable the Pull-Up*/
;;;101      USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;102      /* switch-off device */
;;;103      _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  6020              STR      r0,[r4,#0]
;;;104      /* sw variables reset */
;;;105      /* ... */
;;;106    
;;;107      return USB_SUCCESS;
000016  2000              MOVS     r0,#0
;;;108    }
000018  bd10              POP      {r4,pc}
;;;109    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;63     *******************************************************************************/
;;;64     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66       uint16_t wRegVal;
;;;67     
;;;68       /*** cable plugged-in ? ***/
;;;69       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;70     
;;;71       /*** CNTR_PWDN = 0 ***/
;;;72       wRegVal = CNTR_FRES;
;;;73       _SetCNTR(wRegVal);
000008  4806              LDR      r0,|L2.36|
00000a  2101              MOVS     r1,#1                 ;72
00000c  6001              STR      r1,[r0,#0]
;;;74     
;;;75       /*** CNTR_FRES = 0 ***/
;;;76       wInterrupt_Mask = 0;
00000e  2100              MOVS     r1,#0
000010  4a05              LDR      r2,|L2.40|
;;;77       _SetCNTR(wInterrupt_Mask);
000012  6001              STR      r1,[r0,#0]
;;;78       /*** Clear pending interrupts ***/
;;;79       _SetISTR(0);
000014  1d03              ADDS     r3,r0,#4
000016  6019              STR      r1,[r3,#0]
;;;80       /*** Set interrupt mask ***/
;;;81       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000018  f44f51e0          MOV      r1,#0x1c00
00001c  8011              STRH     r1,[r2,#0]
;;;82       _SetCNTR(wInterrupt_Mask);
00001e  6001              STR      r1,[r0,#0]
;;;83       
;;;84       return USB_SUCCESS;
000020  2000              MOVS     r0,#0
;;;85     }
000022  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L2.36|
                          DCD      0x40005c40
                  |L2.40|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;246    *******************************************************************************/
;;;247    void Resume(RESUME_STATE eResumeSetVal)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;248    {
;;;249      uint16_t wCNTR;
;;;250    
;;;251      if (eResumeSetVal != RESUME_ESOF)
;;;252        ResumeS.eState = eResumeSetVal;
000004  4c21              LDR      r4,|L3.140|
000006  2807              CMP      r0,#7                 ;251
000008  d000              BEQ      |L3.12|
00000a  7020              STRB     r0,[r4,#0]
                  |L3.12|
;;;253      switch (ResumeS.eState)
00000c  7822              LDRB     r2,[r4,#0]  ; ResumeS
;;;254      {
;;;255        case RESUME_EXTERNAL:
;;;256          if (remotewakeupon ==0)
00000e  4d1f              LDR      r5,|L3.140|
;;;257          {
;;;258            Resume_Init();
;;;259            ResumeS.eState = RESUME_OFF;
000010  2706              MOVS     r7,#6
;;;260          }
;;;261          else /* RESUME detected during the RemoteWAkeup signalling => keep RemoteWakeup handling*/
;;;262          {
;;;263            ResumeS.eState = RESUME_ON;
000012  2105              MOVS     r1,#5
;;;264          }
;;;265          break;
;;;266        case RESUME_INTERNAL:
;;;267          Resume_Init();
;;;268          ResumeS.eState = RESUME_START;
000014  2604              MOVS     r6,#4
;;;269          remotewakeupon = 1;
;;;270          break;
;;;271        case RESUME_LATER:
;;;272          ResumeS.bESOFcnt = 2;
;;;273          ResumeS.eState = RESUME_WAIT;
;;;274          break;
;;;275        case RESUME_WAIT:
;;;276          ResumeS.bESOFcnt--;
;;;277          if (ResumeS.bESOFcnt == 0)
;;;278            ResumeS.eState = RESUME_START;
;;;279          break;
;;;280        case RESUME_START:
;;;281          wCNTR = _GetCNTR();
000016  481e              LDR      r0,|L3.144|
000018  2a06              CMP      r2,#6                 ;253
00001a  d20b              BCS      |L3.52|
00001c  e8dff002          TBB      [pc,r2]               ;253
000020  030c1116          DCB      0x03,0x0c,0x11,0x16
000024  1e27              DCB      0x1e,0x27
000026  6868              LDR      r0,[r5,#4]            ;256  ; remotewakeupon
000028  b110              CBZ      r0,|L3.48|
00002a  7021              STRB     r1,[r4,#0]            ;263
                  |L3.44|
;;;282          wCNTR |= CNTR_RESUME;
;;;283          _SetCNTR(wCNTR);
;;;284          ResumeS.eState = RESUME_ON;
;;;285          ResumeS.bESOFcnt = 10;
;;;286          break;
;;;287        case RESUME_ON:    
;;;288          ResumeS.bESOFcnt--;
;;;289          if (ResumeS.bESOFcnt == 0)
;;;290          {
;;;291            wCNTR = _GetCNTR();
;;;292            wCNTR &= (~CNTR_RESUME);
;;;293            _SetCNTR(wCNTR);
;;;294            ResumeS.eState = RESUME_OFF;
;;;295            remotewakeupon = 0;
;;;296          }
;;;297          break;
;;;298        case RESUME_OFF:
;;;299        case RESUME_ESOF:
;;;300        default:
;;;301          ResumeS.eState = RESUME_OFF;
;;;302          break;
;;;303      }
;;;304    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.48|
000030  f7fffffe          BL       Resume_Init
                  |L3.52|
000034  7027              STRB     r7,[r4,#0]            ;301
000036  e7f9              B        |L3.44|
000038  f7fffffe          BL       Resume_Init
00003c  7026              STRB     r6,[r4,#0]            ;268
00003e  2001              MOVS     r0,#1                 ;269
000040  e022              B        |L3.136|
000042  2002              MOVS     r0,#2                 ;272
000044  7060              STRB     r0,[r4,#1]            ;272
000046  2003              MOVS     r0,#3                 ;273
000048  7020              STRB     r0,[r4,#0]            ;273
00004a  e7ef              B        |L3.44|
00004c  7860              LDRB     r0,[r4,#1]            ;276  ; ResumeS
00004e  1e40              SUBS     r0,r0,#1              ;276
000050  7060              STRB     r0,[r4,#1]            ;276
000052  7860              LDRB     r0,[r4,#1]            ;277  ; ResumeS
000054  2800              CMP      r0,#0                 ;277
000056  d1e9              BNE      |L3.44|
000058  7026              STRB     r6,[r4,#0]            ;278
00005a  e7e7              B        |L3.44|
00005c  6802              LDR      r2,[r0,#0]            ;281
00005e  b292              UXTH     r2,r2                 ;281
000060  f0420210          ORR      r2,r2,#0x10           ;282
000064  6002              STR      r2,[r0,#0]            ;283
000066  7021              STRB     r1,[r4,#0]            ;284
000068  200a              MOVS     r0,#0xa               ;285
00006a  7060              STRB     r0,[r4,#1]            ;285
00006c  e7de              B        |L3.44|
00006e  7861              LDRB     r1,[r4,#1]            ;288  ; ResumeS
000070  1e49              SUBS     r1,r1,#1              ;288
000072  7061              STRB     r1,[r4,#1]            ;288
000074  7861              LDRB     r1,[r4,#1]            ;289  ; ResumeS
000076  2900              CMP      r1,#0                 ;289
000078  d1d8              BNE      |L3.44|
00007a  6801              LDR      r1,[r0,#0]            ;291
00007c  b289              UXTH     r1,r1                 ;291
00007e  f0210110          BIC      r1,r1,#0x10           ;292
000082  6001              STR      r1,[r0,#0]            ;293
000084  7027              STRB     r7,[r4,#0]            ;294
000086  2000              MOVS     r0,#0                 ;295
                  |L3.136|
000088  6068              STR      r0,[r5,#4]            ;269  ; remotewakeupon
00008a  e7cf              B        |L3.44|
;;;305    
                          ENDP

                  |L3.140|
                          DCD      ||area_number.11||
                  |L3.144|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;209    *******************************************************************************/
;;;210    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212      uint16_t wCNTR;
;;;213      
;;;214      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;215      /* restart the clocks */
;;;216      /* ...  */
;;;217    
;;;218      /* CNTR_LPMODE = 0 */
;;;219      wCNTR = _GetCNTR();
000002  4c06              LDR      r4,|L4.28|
000004  6820              LDR      r0,[r4,#0]
000006  b280              UXTH     r0,r0
;;;220      wCNTR &= (~CNTR_LPMODE);
000008  f0200004          BIC      r0,r0,#4
;;;221      _SetCNTR(wCNTR);    
00000c  6020              STR      r0,[r4,#0]
;;;222      
;;;223      /* restore full power */
;;;224      /* ... on connected devices */
;;;225      Leave_LowPowerMode();
00000e  f7fffffe          BL       Leave_LowPowerMode
;;;226    
;;;227      /* reset FSUSP bit */
;;;228      _SetCNTR(IMR_MSK);
000012  f44f403f          MOV      r0,#0xbf00
000016  6020              STR      r0,[r4,#0]
;;;229    
;;;230      /* reverse suspend preparation */
;;;231      /* ... */ 
;;;232    
;;;233    }
000018  bd10              POP      {r4,pc}
;;;234    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;116    *******************************************************************************/
;;;117    void Suspend(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;118    {
;;;119    	uint32_t i =0;
;;;120    	uint16_t wCNTR;
;;;121    	uint32_t tmpreg = 0;
;;;122      __IO uint32_t savePWR_CR=0;
;;;123    	/* suspend preparation */
;;;124    	/* ... */
;;;125    	
;;;126    	/*Store CNTR value */
;;;127    	wCNTR = _GetCNTR();  
000002  492b              LDR      r1,|L5.176|
000004  2000              MOVS     r0,#0                 ;119
000006  9000              STR      r0,[sp,#0]
000008  680a              LDR      r2,[r1,#0]
;;;128    
;;;129        /* This a sequence to apply a force RESET to handle a robustness case */
;;;130        
;;;131    	/*Store endpoints registers status */
;;;132        for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
00000a  4b2a              LDR      r3,|L5.180|
00000c  4c2a              LDR      r4,|L5.184|
00000e  b292              UXTH     r2,r2                 ;127
                  |L5.16|
000010  eb030580          ADD      r5,r3,r0,LSL #2
000014  f8d55c00          LDR      r5,[r5,#0xc00]
000018  b2ad              UXTH     r5,r5
00001a  f8445020          STR      r5,[r4,r0,LSL #2]
00001e  1c40              ADDS     r0,r0,#1
000020  2808              CMP      r0,#8
000022  d3f5              BCC      |L5.16|
;;;133    	
;;;134    	/* unmask RESET flag */
;;;135    	wCNTR|=CNTR_RESETM;
000024  f4426080          ORR      r0,r2,#0x400
;;;136    	_SetCNTR(wCNTR);
000028  6008              STR      r0,[r1,#0]
;;;137    	
;;;138    	/*apply FRES */
;;;139    	wCNTR|=CNTR_FRES;
00002a  f0400001          ORR      r0,r0,#1
;;;140    	_SetCNTR(wCNTR);
00002e  6008              STR      r0,[r1,#0]
;;;141    	
;;;142    	/*clear FRES*/
;;;143    	wCNTR&=~CNTR_FRES;
000030  f0200501          BIC      r5,r0,#1
;;;144    	_SetCNTR(wCNTR);
000034  600d              STR      r5,[r1,#0]
;;;145    	
;;;146    	/*poll for RESET flag in ISTR*/
;;;147    	while((_GetISTR()&ISTR_RESET) == 0);
000036  4a1e              LDR      r2,|L5.176|
000038  1d12              ADDS     r2,r2,#4
                  |L5.58|
00003a  6810              LDR      r0,[r2,#0]
00003c  0540              LSLS     r0,r0,#21
00003e  d5fc              BPL      |L5.58|
;;;148    	
;;;149    	/* clear RESET flag in ISTR */
;;;150    	_SetISTR((uint16_t)CLR_RESET);
000040  f64f30ff          MOV      r0,#0xfbff
000044  6010              STR      r0,[r2,#0]
;;;151    	
;;;152    	/*restore Enpoints*/
;;;153    	for (i=0;i<8;i++)
000046  2000              MOVS     r0,#0
                  |L5.72|
;;;154    	_SetENDPOINT(i, EP[i]);
000048  f8546020          LDR      r6,[r4,r0,LSL #2]
00004c  eb030780          ADD      r7,r3,r0,LSL #2
000050  b2b6              UXTH     r6,r6
000052  f8c76c00          STR      r6,[r7,#0xc00]
000056  1c40              ADDS     r0,r0,#1
000058  2808              CMP      r0,#8                 ;153
00005a  d3f5              BCC      |L5.72|
;;;155    	
;;;156    	/* Now it is safe to enter macrocell in suspend mode */
;;;157    	wCNTR |= CNTR_FSUSP;
00005c  f0450008          ORR      r0,r5,#8
;;;158    	_SetCNTR(wCNTR);
000060  6008              STR      r0,[r1,#0]
;;;159    	
;;;160    	/* force low-power mode in the macrocell */
;;;161    	wCNTR = _GetCNTR();
000062  6808              LDR      r0,[r1,#0]
000064  b280              UXTH     r0,r0
;;;162    	wCNTR |= CNTR_LPMODE;
000066  f0400004          ORR      r0,r0,#4
;;;163    	_SetCNTR(wCNTR);
00006a  6008              STR      r0,[r1,#0]
;;;164    	
;;;165    	/*prepare entry in low power mode (STOP mode)*/
;;;166    	/* Select the regulator state in STOP mode*/
;;;167    	savePWR_CR = PWR->CR;
00006c  4b13              LDR      r3,|L5.188|
00006e  6818              LDR      r0,[r3,#0]
;;;168    	tmpreg = PWR->CR;
000070  9000              STR      r0,[sp,#0]
000072  6818              LDR      r0,[r3,#0]
;;;169    	/* Clear PDDS and LPDS bits */
;;;170    	tmpreg &= ((uint32_t)0xFFFFFFFC);
000074  f0200003          BIC      r0,r0,#3
;;;171    	/* Set LPDS bit according to PWR_Regulator value */
;;;172    	tmpreg |= PWR_Regulator_LowPower;
000078  f0400001          ORR      r0,r0,#1
;;;173    	/* Store the new value */
;;;174    	PWR->CR = tmpreg;
00007c  6018              STR      r0,[r3,#0]
;;;175    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;176            SCB->SCR |= SCB_SCR_SLEEPDEEP;       
00007e  4810              LDR      r0,|L5.192|
000080  6804              LDR      r4,[r0,#0]
000082  f0440404          ORR      r4,r4,#4
000086  6004              STR      r4,[r0,#0]
;;;177    	/* enter system in STOP mode, only when wakeup flag in not set */
;;;178    	if((_GetISTR()&ISTR_WKUP)==0)
000088  6814              LDR      r4,[r2,#0]
00008a  04e4              LSLS     r4,r4,#19
00008c  d401              BMI      |L5.146|
;;;179    	{
;;;180    		__WFI();
00008e  bf30              WFI      
;;;181    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;182                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); 
000090  e009              B        |L5.166|
                  |L5.146|
;;;183    	}
;;;184    	else
;;;185    	{
;;;186    		/* Clear Wakeup flag */
;;;187    		_SetISTR(CLR_WKUP);
000092  f64e74ff          MOV      r4,#0xefff
000096  6014              STR      r4,[r2,#0]
;;;188    		/* clear FSUSP to abort entry in suspend mode  */
;;;189            wCNTR = _GetCNTR();
000098  680a              LDR      r2,[r1,#0]
00009a  b292              UXTH     r2,r2
;;;190            wCNTR&=~CNTR_FSUSP;
00009c  f0220208          BIC      r2,r2,#8
;;;191            _SetCNTR(wCNTR);
0000a0  600a              STR      r2,[r1,#0]
;;;192    		
;;;193    		/*restore sleep mode configuration */ 
;;;194    		/* restore Power regulator config in sleep mode*/
;;;195    		PWR->CR = savePWR_CR;
0000a2  9900              LDR      r1,[sp,#0]
0000a4  6019              STR      r1,[r3,#0]
                  |L5.166|
0000a6  6801              LDR      r1,[r0,#0]            ;182
0000a8  f0210104          BIC      r1,r1,#4              ;182
0000ac  6001              STR      r1,[r0,#0]            ;182
;;;196    		
;;;197    		/* Reset SLEEPDEEP bit of Cortex System Control Register */
;;;198                    SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP);
;;;199                  
;;;200        }
;;;201    }
0000ae  bdf8              POP      {r3-r7,pc}
;;;202    
                          ENDP

                  |L5.176|
                          DCD      0x40005c40
                  |L5.180|
                          DCD      0x40005000
                  |L5.184|
                          DCD      ||.bss||
                  |L5.188|
                          DCD      0x40007000
                  |L5.192|
                          DCD      0xe000ed10

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ||EP||
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  fSuspendEnabled
000000  01                DCB      0x01

                          AREA ||area_number.11||, DATA, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.data||
                  ResumeS
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  remotewakeupon
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 144
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
