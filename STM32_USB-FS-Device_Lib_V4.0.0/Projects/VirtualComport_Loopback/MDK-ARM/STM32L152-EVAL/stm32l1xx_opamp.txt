; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm32l152-eval\stm32l1xx_opamp.o --asm_dir=.\STM32L152-EVAL\ --list_dir=.\STM32L152-EVAL\ --depend=.\stm32l152-eval\stm32l1xx_opamp.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32L1xx\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM32L152_EVAL -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil\ARM\Inc\ST\STM32L1xx -D__MICROLIB -DSTM32L1XX_MD -DUSE_STDPERIPH_DRIVER -DSTM32L1XX_MD -DUSE_STM32L152_EVAL ..\..\..\Libraries\STM32L1xx_StdPeriph_Driver\src\stm32l1xx_opamp.c]
                          THUMB

                          AREA ||i.OPAMP_Cmd||, CODE, READONLY, ALIGN=2

                  OPAMP_Cmd PROC
;;;175      */
;;;176    void OPAMP_Cmd(uint32_t OPAMP_Selection, FunctionalState NewState)
000000  4a04              LDR      r2,|L1.20|
;;;177    {
;;;178      /* Check the parameter */
;;;179      assert_param(IS_OPAMP_ALL_PERIPH(OPAMP_Selection));
;;;180      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;181    
;;;182      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;183      {
;;;184        /* Enable the selected OPAMP */
;;;185        OPAMP->CSR &= (~(uint32_t) OPAMP_Selection);
;;;186      }
;;;187      else
;;;188      {
;;;189        /* Disable the selected OPAMP */
;;;190        OPAMP->CSR |= (uint32_t) OPAMP_Selection;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4381              BICS     r1,r1,r0              ;185
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4301              ORRS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;185
;;;191      }
;;;192    }
000010  4770              BX       lr
;;;193    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40007c5c

                          AREA ||i.OPAMP_DeInit||, CODE, READONLY, ALIGN=2

                  OPAMP_DeInit PROC
;;;105      */
;;;106    void OPAMP_DeInit(void)
000000  4907              LDR      r1,|L2.32|
;;;107    {
;;;108      /*!< Set OPAMP_CSR register to reset value */
;;;109      OPAMP->CSR = 0x00010101;
000002  4806              LDR      r0,|L2.28|
000004  6008              STR      r0,[r1,#0]
;;;110      /*!< Set OPAMP_OTR register to reset value */
;;;111      OPAMP->OTR = (uint32_t)(* (uint32_t*)FLASH_R_BASE + 0x00000038);
000006  4807              LDR      r0,|L2.36|
000008  4a05              LDR      r2,|L2.32|
00000a  6800              LDR      r0,[r0,#0]
00000c  1d12              ADDS     r2,r2,#4
00000e  f1000138          ADD      r1,r0,#0x38
000012  6011              STR      r1,[r2,#0]
;;;112      /*!< Set OPAMP_LPOTR register to reset value */
;;;113      OPAMP->LPOTR = (uint32_t)(* (uint32_t*)FLASH_R_BASE + 0x0000003C);
000014  1d11              ADDS     r1,r2,#4
000016  303c              ADDS     r0,r0,#0x3c
000018  6008              STR      r0,[r1,#0]
;;;114    }
00001a  4770              BX       lr
;;;115    
                          ENDP

                  |L2.28|
                          DCD      0x00010101
                  |L2.32|
                          DCD      0x40007c5c
                  |L2.36|
                          DCD      0x40023c00

                          AREA ||i.OPAMP_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  OPAMP_GetFlagStatus PROC
;;;492      */
;;;493    FlagStatus OPAMP_GetFlagStatus(uint32_t OPAMP_Selection)
000000  4908              LDR      r1,|L3.36|
;;;494    {
000002  4602              MOV      r2,r0
;;;495      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;496      uint32_t tmpreg = 0;
;;;497    
;;;498      /* Check the parameter */
;;;499      assert_param(IS_OPAMP_ALL_PERIPH(OPAMP_Selection));
;;;500      
;;;501      /* Get the CSR register value */
;;;502      tmpreg = OPAMP->CSR;
000006  6809              LDR      r1,[r1,#0]
;;;503    
;;;504      /* Check if OPAMP1 is selected */
;;;505      if(OPAMP_Selection == OPAMP_Selection_OPAMP1)
000008  2a01              CMP      r2,#1
00000a  d003              BEQ      |L3.20|
;;;506      {
;;;507        /* Check OPAMP1 CAL bit status */
;;;508        if ((tmpreg & OPAMP_CSR_OPA1CALOUT) != (uint32_t)RESET)
;;;509        {
;;;510          bitstatus = SET;
;;;511        }
;;;512        else
;;;513        {
;;;514          bitstatus = RESET;
;;;515        }
;;;516      }
;;;517      /* Check if OPAMP2 is selected */
;;;518      else if(OPAMP_Selection == OPAMP_Selection_OPAMP2)
00000c  f5b27f80          CMP      r2,#0x100
000010  d004              BEQ      |L3.28|
000012  e004              B        |L3.30|
                  |L3.20|
000014  0089              LSLS     r1,r1,#2              ;508
000016  e002              B        |L3.30|
                  |L3.24|
000018  2001              MOVS     r0,#1                 ;510
;;;519      {
;;;520        /* Check OPAMP2 CAL bit status */
;;;521        if ((tmpreg & OPAMP_CSR_OPA2CALOUT) != (uint32_t)RESET)
;;;522        {
;;;523          bitstatus = SET;
;;;524        } 
;;;525        else
;;;526        {
;;;527          bitstatus = RESET;
;;;528        }
;;;529      }
;;;530      else
;;;531      {
;;;532        /* Check OPAMP3 CAL bit status */
;;;533        if ((tmpreg & OPAMP_CSR_OPA3CALOUT) != (uint32_t)RESET)
;;;534        {
;;;535          bitstatus = SET;
;;;536        }
;;;537        else
;;;538        {
;;;539          bitstatus = RESET;
;;;540        }
;;;541      }
;;;542      return bitstatus;
;;;543    }
00001a  4770              BX       lr
                  |L3.28|
00001c  0049              LSLS     r1,r1,#1              ;521
                  |L3.30|
00001e  2900              CMP      r1,#0                 ;508
000020  dbfa              BLT      |L3.24|
000022  4770              BX       lr
;;;544    
                          ENDP

                  |L3.36|
                          DCD      0x40007c5c

                          AREA ||i.OPAMP_LowPowerCmd||, CODE, READONLY, ALIGN=2

                  OPAMP_LowPowerCmd PROC
;;;204      */
;;;205    void OPAMP_LowPowerCmd(uint32_t OPAMP_Selection, FunctionalState NewState)
000000  4a05              LDR      r2,|L4.24|
;;;206    {
;;;207      /* Check the parameter */
;;;208      assert_param(IS_OPAMP_ALL_PERIPH(OPAMP_Selection));
;;;209      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;210    
;;;211      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;212      {
;;;213        /* Set the selected OPAMP in low power mode */
;;;214        OPAMP->CSR |= (uint32_t) (OPAMP_Selection << 7);
;;;215      }
;;;216      else
;;;217      {
;;;218        /* Disable the low power mode for the selected OPAMP */
;;;219        OPAMP->CSR &= (~(uint32_t) (OPAMP_Selection << 7));
000004  6811              LDR      r1,[r2,#0]
000006  d002              BEQ      |L4.14|
000008  ea4110c0          ORR      r0,r1,r0,LSL #7       ;214
00000c  e001              B        |L4.18|
                  |L4.14|
00000e  ea2110c0          BIC      r0,r1,r0,LSL #7
                  |L4.18|
000012  6010              STR      r0,[r2,#0]            ;214
;;;220      }
;;;221    }
000014  4770              BX       lr
;;;222    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      0x40007c5c

                          AREA ||i.OPAMP_OffsetTrimConfig||, CODE, READONLY, ALIGN=2

                  OPAMP_OffsetTrimConfig PROC
;;;300      */
;;;301    void OPAMP_OffsetTrimConfig(uint32_t OPAMP_Selection, uint32_t OPAMP_Input, uint32_t OPAMP_TrimValue)
000000  b510              PUSH     {r4,lr}
;;;302    {
;;;303      uint32_t tmpreg = 0;
;;;304    
;;;305      /* Check the parameter */
;;;306      assert_param(IS_OPAMP_ALL_PERIPH(OPAMP_Selection));
;;;307      assert_param(IS_OPAMP_INPUT(OPAMP_Input));
;;;308      assert_param(IS_OPAMP_TRIMMINGVALUE(OPAMP_TrimValue));
;;;309    
;;;310      /* Get the OPAMP_OTR value */
;;;311      tmpreg = OPAMP->OTR;
000002  4c1b              LDR      r4,|L5.112|
000004  6823              LDR      r3,[r4,#0]
;;;312    
;;;313      if(OPAMP_Selection == OPAMP_Selection_OPAMP1)
000006  2801              CMP      r0,#1
000008  d00e              BEQ      |L5.40|
;;;314      {
;;;315        /* Reset the OPAMP inputs selection */
;;;316        tmpreg &= (uint32_t)~(OPAMP_CSR_OPA1CAL_L | OPAMP_CSR_OPA1CAL_H);
;;;317        /* Select the OPAMP input */
;;;318        tmpreg |= OPAMP_Input;
;;;319    
;;;320        if(OPAMP_Input == OPAMP_Input_PMOS)
;;;321        {
;;;322          /* Reset the trimming value corresponding to OPAMP1 PMOS input */
;;;323          tmpreg &= (0xFFFFFFE0);
;;;324          /* Set the new trimming value corresponding to OPAMP1 PMOS input */
;;;325          tmpreg |= (OPAMP_TrimValue);
;;;326        }
;;;327        else
;;;328        {
;;;329          /* Reset the trimming value corresponding to OPAMP1 NMOS input */
;;;330          tmpreg &= (0xFFFFFC1F);
;;;331          /* Set the new trimming value corresponding to OPAMP1 NMOS input */
;;;332          tmpreg |= (OPAMP_TrimValue<<5);
;;;333        }
;;;334      }
;;;335      else if (OPAMP_Selection == OPAMP_Selection_OPAMP2)
00000a  f5b07f80          CMP      r0,#0x100
00000e  d019              BEQ      |L5.68|
;;;336      {
;;;337        /* Reset the OPAMP inputs selection */
;;;338        tmpreg &= (uint32_t)~(OPAMP_CSR_OPA2CAL_L | OPAMP_CSR_OPA2CAL_H);
;;;339        /* Select the OPAMP input */
;;;340        tmpreg |= (uint32_t)(OPAMP_Input<<8);
;;;341    
;;;342        if(OPAMP_Input == OPAMP_Input_PMOS)
;;;343        {
;;;344          /* Reset the trimming value corresponding to OPAMP2 PMOS input */
;;;345          tmpreg &= (0xFFFF83FF);
;;;346          /* Set the new trimming value corresponding to OPAMP2 PMOS input */
;;;347          tmpreg |= (OPAMP_TrimValue<<10);
;;;348        }
;;;349        else
;;;350        {
;;;351          /* Reset the trimming value corresponding to OPAMP2 NMOS input */
;;;352          tmpreg &= (0xFFF07FFF);
;;;353          /* Set the new trimming value corresponding to OPAMP2 NMOS input */
;;;354          tmpreg |= (OPAMP_TrimValue<<15);
;;;355        }
;;;356      }
;;;357      else
;;;358      {
;;;359        /* Reset the OPAMP inputs selection */
;;;360        tmpreg &= (uint32_t)~(OPAMP_CSR_OPA3CAL_L | OPAMP_CSR_OPA3CAL_H);
000010  f42300c0          BIC      r0,r3,#0x600000
;;;361        /* Select the OPAMP input */
;;;362        tmpreg |= (uint32_t)(OPAMP_Input<<16);
000014  ea404001          ORR      r0,r0,r1,LSL #16
;;;363    
;;;364        if(OPAMP_Input == OPAMP_Input_PMOS)
000018  2920              CMP      r1,#0x20
00001a  d023              BEQ      |L5.100|
;;;365        {
;;;366          /* Reset the trimming value corresponding to OPAMP3 PMOS input */
;;;367          tmpreg &= (0xFE0FFFFF);
;;;368          /* Set the new trimming value corresponding to OPAMP3 PMOS input */
;;;369          tmpreg |= (OPAMP_TrimValue<<20);
;;;370        }
;;;371        else
;;;372        {
;;;373          /* Reset the trimming value corresponding to OPAMP3 NMOS input */
;;;374          tmpreg &= (0xC1FFFFFF);
00001c  f0205078          BIC      r0,r0,#0x3e000000
;;;375          /* Set the new trimming value corresponding to OPAMP3 NMOS input */
;;;376          tmpreg |= (OPAMP_TrimValue<<25);
000020  ea406042          ORR      r0,r0,r2,LSL #25
                  |L5.36|
;;;377        }
;;;378      }
;;;379    
;;;380      /* Set the OPAMP_OTR register */
;;;381      OPAMP->OTR = tmpreg;
000024  6020              STR      r0,[r4,#0]
;;;382    }
000026  bd10              POP      {r4,pc}
                  |L5.40|
000028  f0230060          BIC      r0,r3,#0x60           ;316
00002c  4308              ORRS     r0,r0,r1              ;318
00002e  2920              CMP      r1,#0x20              ;320
000030  d004              BEQ      |L5.60|
000032  f4207078          BIC      r0,r0,#0x3e0          ;330
000036  ea401042          ORR      r0,r0,r2,LSL #5       ;332
00003a  e7f3              B        |L5.36|
                  |L5.60|
00003c  f020001f          BIC      r0,r0,#0x1f           ;323
000040  4310              ORRS     r0,r0,r2              ;325
000042  e7ef              B        |L5.36|
                  |L5.68|
000044  f42340c0          BIC      r0,r3,#0x6000         ;338
000048  ea402001          ORR      r0,r0,r1,LSL #8       ;340
00004c  2920              CMP      r1,#0x20              ;342
00004e  d004              BEQ      |L5.90|
000050  f4202078          BIC      r0,r0,#0xf8000        ;352
000054  ea4030c2          ORR      r0,r0,r2,LSL #15      ;354
000058  e7e4              B        |L5.36|
                  |L5.90|
00005a  f42040f8          BIC      r0,r0,#0x7c00         ;345
00005e  ea402082          ORR      r0,r0,r2,LSL #10      ;347
000062  e7df              B        |L5.36|
                  |L5.100|
000064  f02070f8          BIC      r0,r0,#0x1f00000      ;367
000068  ea405002          ORR      r0,r0,r2,LSL #20      ;369
00006c  e7da              B        |L5.36|
;;;383    
                          ENDP

00006e  0000              DCW      0x0000
                  |L5.112|
                          DCD      0x40007c60

                          AREA ||i.OPAMP_OffsetTrimLowPowerConfig||, CODE, READONLY, ALIGN=2

                  OPAMP_OffsetTrimLowPowerConfig PROC
;;;398      */
;;;399    void OPAMP_OffsetTrimLowPowerConfig(uint32_t OPAMP_Selection, uint32_t OPAMP_Input, uint32_t OPAMP_TrimValue)
000000  b510              PUSH     {r4,lr}
;;;400    {
;;;401      uint32_t tmpreg = 0;
;;;402    
;;;403      /* Check the parameter */
;;;404      assert_param(IS_OPAMP_ALL_PERIPH(OPAMP_Selection));
;;;405      assert_param(IS_OPAMP_INPUT(OPAMP_Input));
;;;406      assert_param(IS_OPAMP_TRIMMINGVALUE(OPAMP_TrimValue));
;;;407    
;;;408      /* Get the OPAMP_LPOTR value */
;;;409      tmpreg = OPAMP->LPOTR;
000002  4c1b              LDR      r4,|L6.112|
000004  6823              LDR      r3,[r4,#0]
;;;410    
;;;411      if(OPAMP_Selection == OPAMP_Selection_OPAMP1)
000006  2801              CMP      r0,#1
000008  d00e              BEQ      |L6.40|
;;;412      {
;;;413        /* Reset the OPAMP inputs selection */
;;;414        tmpreg &= (uint32_t)~(OPAMP_CSR_OPA1CAL_L | OPAMP_CSR_OPA1CAL_H);
;;;415        /* Select the OPAMP input */
;;;416        tmpreg |= OPAMP_Input;
;;;417    
;;;418        if(OPAMP_Input == OPAMP_Input_PMOS)
;;;419        {
;;;420          /* Reset the trimming value corresponding to OPAMP1 PMOS input */
;;;421          tmpreg &= (0xFFFFFFE0);
;;;422          /* Set the new trimming value corresponding to OPAMP1 PMOS input */
;;;423          tmpreg |= (OPAMP_TrimValue);
;;;424        }
;;;425        else
;;;426        {
;;;427          /* Reset the trimming value corresponding to OPAMP1 NMOS input */
;;;428          tmpreg &= (0xFFFFFC1F);
;;;429          /* Set the new trimming value corresponding to OPAMP1 NMOS input */
;;;430          tmpreg |= (OPAMP_TrimValue<<5);
;;;431        }
;;;432      }
;;;433      else if (OPAMP_Selection == OPAMP_Selection_OPAMP2)
00000a  f5b07f80          CMP      r0,#0x100
00000e  d019              BEQ      |L6.68|
;;;434      {
;;;435        /* Reset the OPAMP inputs selection */
;;;436        tmpreg &= (uint32_t)~(OPAMP_CSR_OPA2CAL_L | OPAMP_CSR_OPA2CAL_H);
;;;437        /* Select the OPAMP input */
;;;438        tmpreg |= (uint32_t)(OPAMP_Input<<8);
;;;439    
;;;440        if(OPAMP_Input == OPAMP_Input_PMOS)
;;;441        {
;;;442          /* Reset the trimming value corresponding to OPAMP2 PMOS input */
;;;443          tmpreg &= (0xFFFF83FF);
;;;444          /* Set the new trimming value corresponding to OPAMP2 PMOS input */
;;;445          tmpreg |= (OPAMP_TrimValue<<10);
;;;446        }
;;;447        else
;;;448        {
;;;449          /* Reset the trimming value corresponding to OPAMP2 NMOS input */
;;;450          tmpreg &= (0xFFF07FFF);
;;;451          /* Set the new trimming value corresponding to OPAMP2 NMOS input */
;;;452          tmpreg |= (OPAMP_TrimValue<<15);
;;;453        }
;;;454      }
;;;455      else
;;;456      {
;;;457        /* Reset the OPAMP inputs selection */
;;;458        tmpreg &= (uint32_t)~(OPAMP_CSR_OPA3CAL_L | OPAMP_CSR_OPA3CAL_H);
000010  f42300c0          BIC      r0,r3,#0x600000
;;;459        /* Select the OPAMP input */
;;;460        tmpreg |= (uint32_t)(OPAMP_Input<<16);
000014  ea404001          ORR      r0,r0,r1,LSL #16
;;;461    
;;;462        if(OPAMP_Input == OPAMP_Input_PMOS)
000018  2920              CMP      r1,#0x20
00001a  d023              BEQ      |L6.100|
;;;463        {
;;;464          /* Reset the trimming value corresponding to OPAMP3 PMOS input */
;;;465          tmpreg &= (0xFE0FFFFF);
;;;466          /* Set the new trimming value corresponding to OPAMP3 PMOS input */
;;;467          tmpreg |= (OPAMP_TrimValue<<20);
;;;468        }
;;;469        else
;;;470        {
;;;471          /* Reset the trimming value corresponding to OPAMP3 NMOS input */
;;;472          tmpreg &= (0xC1FFFFFF);
00001c  f0205078          BIC      r0,r0,#0x3e000000
;;;473          /* Set the new trimming value corresponding to OPAMP3 NMOS input */
;;;474          tmpreg |= (OPAMP_TrimValue<<25);
000020  ea406042          ORR      r0,r0,r2,LSL #25
                  |L6.36|
;;;475        }
;;;476      }
;;;477    
;;;478      /* Set the OPAMP_LPOTR register */
;;;479      OPAMP->LPOTR = tmpreg;
000024  6020              STR      r0,[r4,#0]
;;;480    }
000026  bd10              POP      {r4,pc}
                  |L6.40|
000028  f0230060          BIC      r0,r3,#0x60           ;414
00002c  4308              ORRS     r0,r0,r1              ;416
00002e  2920              CMP      r1,#0x20              ;418
000030  d004              BEQ      |L6.60|
000032  f4207078          BIC      r0,r0,#0x3e0          ;428
000036  ea401042          ORR      r0,r0,r2,LSL #5       ;430
00003a  e7f3              B        |L6.36|
                  |L6.60|
00003c  f020001f          BIC      r0,r0,#0x1f           ;421
000040  4310              ORRS     r0,r0,r2              ;423
000042  e7ef              B        |L6.36|
                  |L6.68|
000044  f42340c0          BIC      r0,r3,#0x6000         ;436
000048  ea402001          ORR      r0,r0,r1,LSL #8       ;438
00004c  2920              CMP      r1,#0x20              ;440
00004e  d004              BEQ      |L6.90|
000050  f4202078          BIC      r0,r0,#0xf8000        ;450
000054  ea4030c2          ORR      r0,r0,r2,LSL #15      ;452
000058  e7e4              B        |L6.36|
                  |L6.90|
00005a  f42040f8          BIC      r0,r0,#0x7c00         ;443
00005e  ea402082          ORR      r0,r0,r2,LSL #10      ;445
000062  e7df              B        |L6.36|
                  |L6.100|
000064  f02070f8          BIC      r0,r0,#0x1f00000      ;465
000068  ea405002          ORR      r0,r0,r2,LSL #20      ;467
00006c  e7da              B        |L6.36|
;;;481    
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      0x40007c64

                          AREA ||i.OPAMP_OffsetTrimmingModeSelect||, CODE, READONLY, ALIGN=2

                  OPAMP_OffsetTrimmingModeSelect PROC
;;;272      */
;;;273    void OPAMP_OffsetTrimmingModeSelect(uint32_t OPAMP_Trimming)
000000  4904              LDR      r1,|L7.20|
;;;274    {
;;;275      /* Check the parameter */
;;;276      assert_param(IS_OPAMP_TRIMMING(OPAMP_Trimming));
;;;277    
;;;278      /* Reset the OPAMP_OTR range bit */
;;;279      OPAMP->CSR &= (~(uint32_t) (OPAMP_OTR_OT_USER));
000002  680a              LDR      r2,[r1,#0]
000004  f0224200          BIC      r2,r2,#0x80000000
000008  600a              STR      r2,[r1,#0]
;;;280    
;;;281      /* Select the OPAMP offset trimming  */
;;;282      OPAMP->CSR |= OPAMP_Trimming;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;283    
;;;284    }
000010  4770              BX       lr
;;;285    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40007c5c

                          AREA ||i.OPAMP_PowerRangeSelect||, CODE, READONLY, ALIGN=2

                  OPAMP_PowerRangeSelect PROC
;;;231      */
;;;232    void OPAMP_PowerRangeSelect(uint32_t OPAMP_PowerRange)
000000  4904              LDR      r1,|L8.20|
;;;233    {
;;;234      /* Check the parameter */
;;;235      assert_param(IS_OPAMP_RANGE(OPAMP_PowerRange));
;;;236    
;;;237      /* Reset the OPAMP range bit */
;;;238      OPAMP->CSR &= (~(uint32_t) (OPAMP_CSR_AOP_RANGE));
000002  680a              LDR      r2,[r1,#0]
000004  f0225280          BIC      r2,r2,#0x10000000
000008  600a              STR      r2,[r1,#0]
;;;239    
;;;240      /* Select the OPAMP power range */
;;;241      OPAMP->CSR |= OPAMP_PowerRange;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;242    }
000010  4770              BX       lr
;;;243    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40007c5c

                          AREA ||i.OPAMP_SwitchCmd||, CODE, READONLY, ALIGN=2

                  OPAMP_SwitchCmd PROC
;;;146      */
;;;147    void OPAMP_SwitchCmd(uint32_t OPAMP_OPAMPxSwitchy, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;148    {
;;;149      /* Check the parameter */
;;;150      assert_param(IS_OPAMP_SWITCH(OPAMP_OPAMPxSwitchy));
;;;151      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;152    
;;;153      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;154      {
;;;155        /* Close the selected switches */
;;;156        OPAMP->CSR |= (uint32_t) OPAMP_OPAMPxSwitchy;
;;;157      }
;;;158      else
;;;159      {
;;;160        /* Open the selected switches */
;;;161        OPAMP->CSR &= (~(uint32_t)OPAMP_OPAMPxSwitchy);
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;156
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;156
;;;162      }
;;;163    }
000010  4770              BX       lr
;;;164    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40007c5c

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Libraries\\STM32L1xx_StdPeriph_Driver\\src\\stm32l1xx_opamp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32l1xx_opamp_c_1d9bf58d____REV16|
#line 129 "C:\\Keil\\ARM\\PACK\\ARM\\CMSIS\\4.1.1\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32l1xx_opamp_c_1d9bf58d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32l1xx_opamp_c_1d9bf58d____REVSH|
#line 144
|__asm___17_stm32l1xx_opamp_c_1d9bf58d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
